// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE

import * as $$Map from "bs-platform/lib/es6/map.js";
import * as $$Set from "bs-platform/lib/es6/set.js";
import * as Curry from "bs-platform/lib/es6/curry.js";
import * as Crdt$DeltaCrdts from "./Crdt.bs.js";

function State($$Element, Timestamp, InOrOut) {
  var partial_arg = Crdt$DeltaCrdts.LexicographicPair;
  var LexState = partial_arg(Timestamp, {
        empty: InOrOut.empty,
        join: InOrOut.join
      });
  var Data = $$Map.Make($$Element);
  var empty = Data.empty;
  var insert = function (element, time) {
    return Curry._3(Data.add, element, /* tuple */[
                time,
                InOrOut.isIn
              ], empty);
  };
  var remove = function (element, time) {
    return Curry._3(Data.add, element, /* tuple */[
                time,
                InOrOut.isOut
              ], empty);
  };
  var join = function (m, m$prime) {
    return Curry._3(Data.merge, (function (param, mState, mState$prime) {
                  if (mState !== undefined) {
                    if (mState$prime !== undefined) {
                      return Curry._2(LexState.join, mState, mState$prime);
                    } else {
                      return Curry._2(LexState.join, mState, LexState.empty);
                    }
                  } else if (mState$prime !== undefined) {
                    return Curry._2(LexState.join, mState$prime, LexState.empty);
                  } else {
                    return ;
                  }
                }), m, m$prime);
  };
  var ElSet = $$Set.Make($$Element);
  var elements = function (m) {
    return Curry._3(Data.fold, (function (elementKey, param, elements) {
                  if (param[1]) {
                    return Curry._2(ElSet.add, elementKey, elements);
                  } else {
                    return elements;
                  }
                }), m, ElSet.empty);
  };
  return {
          LexState: LexState,
          Data: Data,
          empty: empty,
          insert: insert,
          remove: remove,
          join: join,
          ElSet: ElSet,
          elements: elements
        };
}

function Make(Id, $$Element, Timestamp, InOrOut) {
  var partial_arg = Crdt$DeltaCrdts.LexicographicPair;
  var LexState = partial_arg(Timestamp, {
        empty: InOrOut.empty,
        join: InOrOut.join
      });
  var Data = $$Map.Make($$Element);
  var partial_arg$1 = Crdt$DeltaCrdts.LexicographicPair;
  var LexState$1 = partial_arg$1(Timestamp, {
        empty: InOrOut.empty,
        join: InOrOut.join
      });
  var Data$1 = $$Map.Make($$Element);
  var empty = Data$1.empty;
  var insert = function (element, time) {
    return Curry._3(Data$1.add, element, /* tuple */[
                time,
                InOrOut.isIn
              ], empty);
  };
  var remove = function (element, time) {
    return Curry._3(Data$1.add, element, /* tuple */[
                time,
                InOrOut.isOut
              ], empty);
  };
  var join = function (m, m$prime) {
    return Curry._3(Data$1.merge, (function (param, mState, mState$prime) {
                  if (mState !== undefined) {
                    if (mState$prime !== undefined) {
                      return Curry._2(LexState$1.join, mState, mState$prime);
                    } else {
                      return Curry._2(LexState$1.join, mState, LexState$1.empty);
                    }
                  } else if (mState$prime !== undefined) {
                    return Curry._2(LexState$1.join, mState$prime, LexState$1.empty);
                  } else {
                    return ;
                  }
                }), m, m$prime);
  };
  var ElSet = $$Set.Make($$Element);
  var elements = function (m) {
    return Curry._3(Data$1.fold, (function (elementKey, param, elements) {
                  if (param[1]) {
                    return Curry._2(ElSet.add, elementKey, elements);
                  } else {
                    return elements;
                  }
                }), m, ElSet.empty);
  };
  var State = {
    LexState: LexState$1,
    Data: Data$1,
    empty: empty,
    insert: insert,
    remove: remove,
    join: join,
    ElSet: ElSet,
    elements: elements
  };
  var partial_arg$2 = Crdt$DeltaCrdts.Make;
  var include = partial_arg$2(Id, {
        empty: empty,
        join: join
      });
  var mutate = include.mutate;
  var elements$1 = function (param) {
    return Curry._1(elements, param.state);
  };
  var insert$1 = function (replica, element, time) {
    return Curry._2(mutate, replica, Curry._2(insert, element, time));
  };
  var remove$1 = function (replica, element, time) {
    return Curry._2(mutate, replica, Curry._2(remove, element, time));
  };
  return {
          LexState: LexState,
          Data: Data,
          State: State,
          replica: include.replica,
          join: include.join,
          patchOfState: include.patchOfState,
          mutate: mutate,
          elements: elements$1,
          insert: insert$1,
          remove: remove$1
        };
}

var InOrOut = {
  empty: false,
  isOut: false,
  isIn: true
};

function join(a, b) {
  if (a) {
    return true;
  } else {
    return b;
  }
}

var InOrOutAddStays = {
  empty: false,
  isOut: false,
  isIn: true,
  join: join
};

function join$1(a, b) {
  if (a) {
    return b;
  } else {
    return false;
  }
}

var InOrOutRemoveStays = {
  empty: false,
  isOut: false,
  isIn: true,
  join: join$1
};

function AddWins(Id, $$Element, Timestamp) {
  var partial_arg = Crdt$DeltaCrdts.LexicographicPair;
  var LexState = partial_arg(Timestamp, {
        empty: false,
        join: join
      });
  var Data = $$Map.Make($$Element);
  var partial_arg$1 = Crdt$DeltaCrdts.LexicographicPair;
  var LexState$1 = partial_arg$1(Timestamp, {
        empty: false,
        join: join
      });
  var Data$1 = $$Map.Make($$Element);
  var empty = Data$1.empty;
  var insert = function (element, time) {
    return Curry._3(Data$1.add, element, /* tuple */[
                time,
                true
              ], empty);
  };
  var remove = function (element, time) {
    return Curry._3(Data$1.add, element, /* tuple */[
                time,
                false
              ], empty);
  };
  var join$2 = function (m, m$prime) {
    return Curry._3(Data$1.merge, (function (param, mState, mState$prime) {
                  if (mState !== undefined) {
                    if (mState$prime !== undefined) {
                      return Curry._2(LexState$1.join, mState, mState$prime);
                    } else {
                      return Curry._2(LexState$1.join, mState, LexState$1.empty);
                    }
                  } else if (mState$prime !== undefined) {
                    return Curry._2(LexState$1.join, mState$prime, LexState$1.empty);
                  } else {
                    return ;
                  }
                }), m, m$prime);
  };
  var ElSet = $$Set.Make($$Element);
  var elements = function (m) {
    return Curry._3(Data$1.fold, (function (elementKey, param, elements) {
                  if (param[1]) {
                    return Curry._2(ElSet.add, elementKey, elements);
                  } else {
                    return elements;
                  }
                }), m, ElSet.empty);
  };
  var State = {
    LexState: LexState$1,
    Data: Data$1,
    empty: empty,
    insert: insert,
    remove: remove,
    join: join$2,
    ElSet: ElSet,
    elements: elements
  };
  var partial_arg$2 = Crdt$DeltaCrdts.Make;
  var include = partial_arg$2(Id, {
        empty: empty,
        join: join$2
      });
  var mutate = include.mutate;
  var elements$1 = function (param) {
    return Curry._1(elements, param.state);
  };
  var insert$1 = function (replica, element, time) {
    return Curry._2(mutate, replica, Curry._2(insert, element, time));
  };
  var remove$1 = function (replica, element, time) {
    return Curry._2(mutate, replica, Curry._2(remove, element, time));
  };
  var Make_replica = include.replica;
  var Make_join = include.join;
  var Make_patchOfState = include.patchOfState;
  var Make = {
    LexState: LexState,
    Data: Data,
    State: State,
    replica: Make_replica,
    join: Make_join,
    patchOfState: Make_patchOfState,
    mutate: mutate,
    elements: elements$1,
    insert: insert$1,
    remove: remove$1
  };
  return {
          Make: Make
        };
}

function RemoveWins(Id, $$Element, Timestamp) {
  var partial_arg = Crdt$DeltaCrdts.LexicographicPair;
  var LexState = partial_arg(Timestamp, {
        empty: false,
        join: join$1
      });
  var Data = $$Map.Make($$Element);
  var partial_arg$1 = Crdt$DeltaCrdts.LexicographicPair;
  var LexState$1 = partial_arg$1(Timestamp, {
        empty: false,
        join: join$1
      });
  var Data$1 = $$Map.Make($$Element);
  var empty = Data$1.empty;
  var insert = function (element, time) {
    return Curry._3(Data$1.add, element, /* tuple */[
                time,
                true
              ], empty);
  };
  var remove = function (element, time) {
    return Curry._3(Data$1.add, element, /* tuple */[
                time,
                false
              ], empty);
  };
  var join$2 = function (m, m$prime) {
    return Curry._3(Data$1.merge, (function (param, mState, mState$prime) {
                  if (mState !== undefined) {
                    if (mState$prime !== undefined) {
                      return Curry._2(LexState$1.join, mState, mState$prime);
                    } else {
                      return Curry._2(LexState$1.join, mState, LexState$1.empty);
                    }
                  } else if (mState$prime !== undefined) {
                    return Curry._2(LexState$1.join, mState$prime, LexState$1.empty);
                  } else {
                    return ;
                  }
                }), m, m$prime);
  };
  var ElSet = $$Set.Make($$Element);
  var elements = function (m) {
    return Curry._3(Data$1.fold, (function (elementKey, param, elements) {
                  if (param[1]) {
                    return Curry._2(ElSet.add, elementKey, elements);
                  } else {
                    return elements;
                  }
                }), m, ElSet.empty);
  };
  var State = {
    LexState: LexState$1,
    Data: Data$1,
    empty: empty,
    insert: insert,
    remove: remove,
    join: join$2,
    ElSet: ElSet,
    elements: elements
  };
  var partial_arg$2 = Crdt$DeltaCrdts.Make;
  var include = partial_arg$2(Id, {
        empty: empty,
        join: join$2
      });
  var mutate = include.mutate;
  var elements$1 = function (param) {
    return Curry._1(elements, param.state);
  };
  var insert$1 = function (replica, element, time) {
    return Curry._2(mutate, replica, Curry._2(insert, element, time));
  };
  var remove$1 = function (replica, element, time) {
    return Curry._2(mutate, replica, Curry._2(remove, element, time));
  };
  var Make_replica = include.replica;
  var Make_join = include.join;
  var Make_patchOfState = include.patchOfState;
  var Make = {
    LexState: LexState,
    Data: Data,
    State: State,
    replica: Make_replica,
    join: Make_join,
    patchOfState: Make_patchOfState,
    mutate: mutate,
    elements: elements$1,
    insert: insert$1,
    remove: remove$1
  };
  return {
          Make: Make
        };
}

export {
  State ,
  Make ,
  InOrOut ,
  InOrOutAddStays ,
  InOrOutRemoveStays ,
  AddWins ,
  RemoveWins ,
  
}
/* No side effect */
