// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE

import * as $$Map from "bs-platform/lib/es6/map.js";
import * as $$Set from "bs-platform/lib/es6/set.js";
import * as Curry from "bs-platform/lib/es6/curry.js";
import * as Crdt$DeltaCrdts from "./Crdt.bs.js";

function Make(Id, $$Element, Timestamp, InOrOut) {
  var partial_arg = Crdt$DeltaCrdts.LexicographicPair;
  var LexState = partial_arg(Timestamp, InOrOut);
  var Data = $$Map.Make($$Element);
  var empty = Data.empty;
  var insert = function (element, time) {
    return Curry._3(Data.add, element, /* tuple */[
                time,
                InOrOut.isIn
              ], empty);
  };
  var remove = function (element, time) {
    return Curry._3(Data.add, element, /* tuple */[
                time,
                InOrOut.isOut
              ], empty);
  };
  var join = function (m, m$prime) {
    return Curry._3(Data.merge, (function (param, mState, mState$prime) {
                  if (mState !== undefined) {
                    if (mState$prime !== undefined) {
                      return Curry._2(LexState.join, mState, mState$prime);
                    } else {
                      return Curry._2(LexState.join, mState, LexState.empty);
                    }
                  } else if (mState$prime !== undefined) {
                    return Curry._2(LexState.join, mState$prime, LexState.empty);
                  } else {
                    return ;
                  }
                }), m, m$prime);
  };
  var State = {
    empty: empty,
    insert: insert,
    remove: remove,
    join: join
  };
  var partial_arg$1 = Crdt$DeltaCrdts.Make;
  var include = partial_arg$1(Id, {
        empty: empty,
        join: join
      });
  var deltaOfState = include.deltaOfState;
  var mutate = include.mutate;
  var ElSet = $$Set.Make($$Element);
  var elements = function (m) {
    return Curry._3(Data.fold, (function (key, param, elSet) {
                  if (param[1]) {
                    return Curry._2(ElSet.add, key, elSet);
                  } else {
                    return elSet;
                  }
                }), m, ElSet.empty);
  };
  var insert$1 = function (replica, element, time) {
    return Curry._2(mutate, replica, Curry._1(deltaOfState, insert(element, time)));
  };
  var remove$1 = function (replica, element, time) {
    return Curry._2(mutate, replica, Curry._1(deltaOfState, remove(element, time)));
  };
  return {
          LexState: LexState,
          Data: Data,
          State: State,
          replica: include.replica,
          deltaOfState: deltaOfState,
          join: include.join,
          mutate: mutate,
          ElSet: ElSet,
          elements: elements,
          insert: insert$1,
          remove: remove$1
        };
}

var InOrOut = {
  empty: false,
  isOut: false,
  isIn: true
};

function join(a, b) {
  if (a) {
    return true;
  } else {
    return b;
  }
}

var IsInAddStays = {
  empty: false,
  isOut: false,
  isIn: true,
  join: join
};

function join$1(a, b) {
  if (a) {
    return b;
  } else {
    return false;
  }
}

var IsInRemoveStays = {
  empty: false,
  isOut: false,
  isIn: true,
  join: join$1
};

function AddWins(Id, $$Element, Timestamp) {
  var param = {
    empty: false,
    join: join,
    isIn: true,
    isOut: false
  };
  var partial_arg = Crdt$DeltaCrdts.LexicographicPair;
  var LexState = partial_arg(Timestamp, param);
  var Data = $$Map.Make($$Element);
  var empty = Data.empty;
  var insert = function (element, time) {
    return Curry._3(Data.add, element, /* tuple */[
                time,
                true
              ], empty);
  };
  var remove = function (element, time) {
    return Curry._3(Data.add, element, /* tuple */[
                time,
                false
              ], empty);
  };
  var join$2 = function (m, m$prime) {
    return Curry._3(Data.merge, (function (param, mState, mState$prime) {
                  if (mState !== undefined) {
                    if (mState$prime !== undefined) {
                      return Curry._2(LexState.join, mState, mState$prime);
                    } else {
                      return Curry._2(LexState.join, mState, LexState.empty);
                    }
                  } else if (mState$prime !== undefined) {
                    return Curry._2(LexState.join, mState$prime, LexState.empty);
                  } else {
                    return ;
                  }
                }), m, m$prime);
  };
  var State = {
    empty: empty,
    insert: insert,
    remove: remove,
    join: join$2
  };
  var partial_arg$1 = Crdt$DeltaCrdts.Make;
  var include = partial_arg$1(Id, {
        empty: empty,
        join: join$2
      });
  var deltaOfState = include.deltaOfState;
  var mutate = include.mutate;
  var ElSet = $$Set.Make($$Element);
  var elements = function (m) {
    return Curry._3(Data.fold, (function (key, param, elSet) {
                  if (param[1]) {
                    return Curry._2(ElSet.add, key, elSet);
                  } else {
                    return elSet;
                  }
                }), m, ElSet.empty);
  };
  var insert$1 = function (replica, element, time) {
    return Curry._2(mutate, replica, Curry._1(deltaOfState, insert(element, time)));
  };
  var remove$1 = function (replica, element, time) {
    return Curry._2(mutate, replica, Curry._1(deltaOfState, remove(element, time)));
  };
  var Make_replica = include.replica;
  var Make_join = include.join;
  var Make = {
    LexState: LexState,
    Data: Data,
    State: State,
    replica: Make_replica,
    deltaOfState: deltaOfState,
    join: Make_join,
    mutate: mutate,
    ElSet: ElSet,
    elements: elements,
    insert: insert$1,
    remove: remove$1
  };
  return {
          Make: Make
        };
}

function RemoveWins(Id, $$Element, Timestamp) {
  var param = {
    empty: false,
    join: join$1,
    isIn: true,
    isOut: false
  };
  var partial_arg = Crdt$DeltaCrdts.LexicographicPair;
  var LexState = partial_arg(Timestamp, param);
  var Data = $$Map.Make($$Element);
  var empty = Data.empty;
  var insert = function (element, time) {
    return Curry._3(Data.add, element, /* tuple */[
                time,
                true
              ], empty);
  };
  var remove = function (element, time) {
    return Curry._3(Data.add, element, /* tuple */[
                time,
                false
              ], empty);
  };
  var join$2 = function (m, m$prime) {
    return Curry._3(Data.merge, (function (param, mState, mState$prime) {
                  if (mState !== undefined) {
                    if (mState$prime !== undefined) {
                      return Curry._2(LexState.join, mState, mState$prime);
                    } else {
                      return Curry._2(LexState.join, mState, LexState.empty);
                    }
                  } else if (mState$prime !== undefined) {
                    return Curry._2(LexState.join, mState$prime, LexState.empty);
                  } else {
                    return ;
                  }
                }), m, m$prime);
  };
  var State = {
    empty: empty,
    insert: insert,
    remove: remove,
    join: join$2
  };
  var partial_arg$1 = Crdt$DeltaCrdts.Make;
  var include = partial_arg$1(Id, {
        empty: empty,
        join: join$2
      });
  var deltaOfState = include.deltaOfState;
  var mutate = include.mutate;
  var ElSet = $$Set.Make($$Element);
  var elements = function (m) {
    return Curry._3(Data.fold, (function (key, param, elSet) {
                  if (param[1]) {
                    return Curry._2(ElSet.add, key, elSet);
                  } else {
                    return elSet;
                  }
                }), m, ElSet.empty);
  };
  var insert$1 = function (replica, element, time) {
    return Curry._2(mutate, replica, Curry._1(deltaOfState, insert(element, time)));
  };
  var remove$1 = function (replica, element, time) {
    return Curry._2(mutate, replica, Curry._1(deltaOfState, remove(element, time)));
  };
  var Make_replica = include.replica;
  var Make_join = include.join;
  var Make = {
    LexState: LexState,
    Data: Data,
    State: State,
    replica: Make_replica,
    deltaOfState: deltaOfState,
    join: Make_join,
    mutate: mutate,
    ElSet: ElSet,
    elements: elements,
    insert: insert$1,
    remove: remove$1
  };
  return {
          Make: Make
        };
}

export {
  Make ,
  InOrOut ,
  IsInAddStays ,
  IsInRemoveStays ,
  AddWins ,
  RemoveWins ,
  
}
/* No side effect */
