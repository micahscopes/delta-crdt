// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE

import * as $$Map from "bs-platform/lib/es6/map.js";
import * as $$Set from "bs-platform/lib/es6/set.js";
import * as Curry from "bs-platform/lib/es6/curry.js";
import * as Crdt$DeltaCrdts from "./Crdt.bs.js";

function State($$Element, Timestamp, InOrOut) {
  var partial_arg = Crdt$DeltaCrdts.LexicographicPair;
  var LexState = partial_arg(Timestamp, {
        empty: InOrOut.empty,
        join: InOrOut.join
      });
  var partial_arg$1 = Crdt$DeltaCrdts.SimpleMap;
  var include = partial_arg$1($$Element, LexState);
  var Data = include.Data;
  var insert = function (element, time) {
    return Curry._2(Data.singleton, element, /* tuple */[
                time,
                InOrOut.isIn
              ]);
  };
  var remove = function (element, time) {
    return Curry._2(Data.singleton, element, /* tuple */[
                time,
                InOrOut.isOut
              ]);
  };
  var ElSet = $$Set.Make({
        compare: $$Element.compare
      });
  var elements = function (m) {
    return Curry._3(Data.fold, (function (elementKey, param, elements) {
                  if (param[1]) {
                    return Curry._2(ElSet.add, elementKey, elements);
                  } else {
                    return elements;
                  }
                }), m, ElSet.empty);
  };
  return {
          LexState: LexState,
          Data: Data,
          empty: include.empty,
          join: include.join,
          insert: insert,
          remove: remove,
          ElSet: ElSet,
          elements: elements
        };
}

function Make(Id, $$Element, Timestamp, InOrOut) {
  var partial_arg = Crdt$DeltaCrdts.LexicographicPair;
  var LexState = partial_arg(Timestamp, {
        empty: InOrOut.empty,
        join: InOrOut.join
      });
  var Data = $$Map.Make({
        compare: $$Element.compare
      });
  var partial_arg$1 = Crdt$DeltaCrdts.LexicographicPair;
  var LexState$1 = partial_arg$1(Timestamp, {
        empty: InOrOut.empty,
        join: InOrOut.join
      });
  var partial_arg$2 = Crdt$DeltaCrdts.SimpleMap;
  var include = partial_arg$2($$Element, LexState$1);
  var Data$1 = include.Data;
  var insert = function (element, time) {
    return Curry._2(Data$1.singleton, element, /* tuple */[
                time,
                InOrOut.isIn
              ]);
  };
  var remove = function (element, time) {
    return Curry._2(Data$1.singleton, element, /* tuple */[
                time,
                InOrOut.isOut
              ]);
  };
  var ElSet = $$Set.Make({
        compare: $$Element.compare
      });
  var elements = function (m) {
    return Curry._3(Data$1.fold, (function (elementKey, param, elements) {
                  if (param[1]) {
                    return Curry._2(ElSet.add, elementKey, elements);
                  } else {
                    return elements;
                  }
                }), m, ElSet.empty);
  };
  var State_empty = include.empty;
  var State_join = include.join;
  var State = {
    LexState: LexState$1,
    Data: Data$1,
    empty: State_empty,
    join: State_join,
    insert: insert,
    remove: remove,
    ElSet: ElSet,
    elements: elements
  };
  var partial_arg$3 = Crdt$DeltaCrdts.Make;
  var include$1 = partial_arg$3(Id, {
        empty: State_empty,
        join: State_join
      });
  var mutate = include$1.mutate;
  var elements$1 = function (param) {
    return Curry._1(elements, param.state);
  };
  var insert$1 = function (replica, element, time) {
    return Curry._2(mutate, replica, Curry._2(insert, element, time));
  };
  var remove$1 = function (replica, element, time) {
    return Curry._2(mutate, replica, Curry._2(remove, element, time));
  };
  return {
          LexState: LexState,
          Data: Data,
          State: State,
          replica: include$1.replica,
          join: include$1.join,
          patchOfState: include$1.patchOfState,
          mutate: mutate,
          elements: elements$1,
          insert: insert$1,
          remove: remove$1
        };
}

var InOrOut = {
  empty: false,
  isOut: false,
  isIn: true
};

function join(a, b) {
  if (a) {
    return true;
  } else {
    return b;
  }
}

var InOrOutAddStays = {
  empty: false,
  isOut: false,
  isIn: true,
  join: join
};

function join$1(a, b) {
  if (a) {
    return b;
  } else {
    return false;
  }
}

var InOrOutRemoveStays = {
  empty: false,
  isOut: false,
  isIn: true,
  join: join$1
};

function AddWins(Id, $$Element, Timestamp) {
  var partial_arg = Crdt$DeltaCrdts.LexicographicPair;
  var LexState = partial_arg(Timestamp, {
        empty: false,
        join: join
      });
  var Data = $$Map.Make({
        compare: $$Element.compare
      });
  var partial_arg$1 = Crdt$DeltaCrdts.LexicographicPair;
  var LexState$1 = partial_arg$1(Timestamp, {
        empty: false,
        join: join
      });
  var partial_arg$2 = Crdt$DeltaCrdts.SimpleMap;
  var include = partial_arg$2($$Element, LexState$1);
  var Data$1 = include.Data;
  var insert = function (element, time) {
    return Curry._2(Data$1.singleton, element, /* tuple */[
                time,
                true
              ]);
  };
  var remove = function (element, time) {
    return Curry._2(Data$1.singleton, element, /* tuple */[
                time,
                false
              ]);
  };
  var ElSet = $$Set.Make({
        compare: $$Element.compare
      });
  var elements = function (m) {
    return Curry._3(Data$1.fold, (function (elementKey, param, elements) {
                  if (param[1]) {
                    return Curry._2(ElSet.add, elementKey, elements);
                  } else {
                    return elements;
                  }
                }), m, ElSet.empty);
  };
  var State_empty = include.empty;
  var State_join = include.join;
  var State = {
    LexState: LexState$1,
    Data: Data$1,
    empty: State_empty,
    join: State_join,
    insert: insert,
    remove: remove,
    ElSet: ElSet,
    elements: elements
  };
  var partial_arg$3 = Crdt$DeltaCrdts.Make;
  var include$1 = partial_arg$3(Id, {
        empty: State_empty,
        join: State_join
      });
  var mutate = include$1.mutate;
  var elements$1 = function (param) {
    return Curry._1(elements, param.state);
  };
  var insert$1 = function (replica, element, time) {
    return Curry._2(mutate, replica, Curry._2(insert, element, time));
  };
  var remove$1 = function (replica, element, time) {
    return Curry._2(mutate, replica, Curry._2(remove, element, time));
  };
  var Make_replica = include$1.replica;
  var Make_join = include$1.join;
  var Make_patchOfState = include$1.patchOfState;
  var Make = {
    LexState: LexState,
    Data: Data,
    State: State,
    replica: Make_replica,
    join: Make_join,
    patchOfState: Make_patchOfState,
    mutate: mutate,
    elements: elements$1,
    insert: insert$1,
    remove: remove$1
  };
  return {
          Make: Make
        };
}

function RemoveWins(Id, $$Element, Timestamp) {
  var partial_arg = Crdt$DeltaCrdts.LexicographicPair;
  var LexState = partial_arg(Timestamp, {
        empty: false,
        join: join$1
      });
  var Data = $$Map.Make({
        compare: $$Element.compare
      });
  var partial_arg$1 = Crdt$DeltaCrdts.LexicographicPair;
  var LexState$1 = partial_arg$1(Timestamp, {
        empty: false,
        join: join$1
      });
  var partial_arg$2 = Crdt$DeltaCrdts.SimpleMap;
  var include = partial_arg$2($$Element, LexState$1);
  var Data$1 = include.Data;
  var insert = function (element, time) {
    return Curry._2(Data$1.singleton, element, /* tuple */[
                time,
                true
              ]);
  };
  var remove = function (element, time) {
    return Curry._2(Data$1.singleton, element, /* tuple */[
                time,
                false
              ]);
  };
  var ElSet = $$Set.Make({
        compare: $$Element.compare
      });
  var elements = function (m) {
    return Curry._3(Data$1.fold, (function (elementKey, param, elements) {
                  if (param[1]) {
                    return Curry._2(ElSet.add, elementKey, elements);
                  } else {
                    return elements;
                  }
                }), m, ElSet.empty);
  };
  var State_empty = include.empty;
  var State_join = include.join;
  var State = {
    LexState: LexState$1,
    Data: Data$1,
    empty: State_empty,
    join: State_join,
    insert: insert,
    remove: remove,
    ElSet: ElSet,
    elements: elements
  };
  var partial_arg$3 = Crdt$DeltaCrdts.Make;
  var include$1 = partial_arg$3(Id, {
        empty: State_empty,
        join: State_join
      });
  var mutate = include$1.mutate;
  var elements$1 = function (param) {
    return Curry._1(elements, param.state);
  };
  var insert$1 = function (replica, element, time) {
    return Curry._2(mutate, replica, Curry._2(insert, element, time));
  };
  var remove$1 = function (replica, element, time) {
    return Curry._2(mutate, replica, Curry._2(remove, element, time));
  };
  var Make_replica = include$1.replica;
  var Make_join = include$1.join;
  var Make_patchOfState = include$1.patchOfState;
  var Make = {
    LexState: LexState,
    Data: Data,
    State: State,
    replica: Make_replica,
    join: Make_join,
    patchOfState: Make_patchOfState,
    mutate: mutate,
    elements: elements$1,
    insert: insert$1,
    remove: remove$1
  };
  return {
          Make: Make
        };
}

export {
  State ,
  Make ,
  InOrOut ,
  InOrOutAddStays ,
  InOrOutRemoveStays ,
  AddWins ,
  RemoveWins ,
  
}
/* No side effect */
