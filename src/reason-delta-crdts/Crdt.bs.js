// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE

import * as Block from "bs-platform/lib/es6/block.js";
import * as Curry from "bs-platform/lib/es6/curry.js";
import * as Caml_option from "bs-platform/lib/es6/caml_option.js";

function ComparableOfOrderedType(T) {
  var compare = function (t, t$prime) {
    var comparison = Curry._2(T.compare, t, t$prime);
    if (comparison < 0) {
      return /* Left */Block.__(0, [t]);
    } else if (comparison > 0) {
      return /* Right */Block.__(1, [t$prime]);
    } else if (comparison === 0) {
      return /* Either */Block.__(2, [
                t,
                t$prime
              ]);
    } else {
      return /* Neither */Block.__(3, [
                t,
                t$prime
              ]);
    }
  };
  return {
          compare: compare
        };
}

function Make(Id, State) {
  var replica = function (id) {
    return {
            id: id,
            state: State.empty
          };
  };
  var join = function (p, q) {
    var match = p.id;
    var match$1 = q.id;
    var id;
    if (match !== undefined) {
      var id$1 = Caml_option.valFromOption(match);
      id = Caml_option.some(id$1);
    } else {
      id = match$1 !== undefined ? Caml_option.some(Caml_option.valFromOption(match$1)) : undefined;
    }
    var state = Curry._2(State.join, p.state, q.state);
    return {
            id: id,
            state: state
          };
  };
  var patchOfState = function (idOpt, state) {
    var id = idOpt !== undefined ? Caml_option.valFromOption(idOpt) : undefined;
    return {
            id: id,
            state: state
          };
  };
  var mutate = function (replica, deltaMutation) {
    var delta = patchOfState(undefined, deltaMutation);
    var match = replica.id;
    if (match !== undefined) {
      return /* Result */Block.__(0, [
                /* replica */join(replica, delta),
                /* delta */delta
              ]);
    } else {
      return /* Invalid */Block.__(1, [
                /* replica */replica,
                /* delta */delta
              ]);
    }
  };
  return {
          replica: replica,
          join: join,
          patchOfState: patchOfState,
          mutate: mutate
        };
}

function Pair(A, B) {
  var empty_000 = A.empty;
  var empty_001 = B.empty;
  var empty = /* tuple */[
    empty_000,
    empty_001
  ];
  var join = function (param, param$1) {
    return /* tuple */[
            Curry._2(A.join, param[0], param$1[0]),
            Curry._2(B.join, param[1], param$1[1])
          ];
  };
  return {
          empty: empty,
          join: join
        };
}

function LexicographicPair(A, B) {
  var empty_000 = A.empty;
  var empty_001 = B.empty;
  var empty = /* tuple */[
    empty_000,
    empty_001
  ];
  var join = function (param, param$1) {
    var b$prime = param$1[1];
    var b = param[1];
    var priority = Curry._2(A.compare, param[0], param$1[0]);
    switch (priority.tag | 0) {
      case /* Left */0 :
          return /* tuple */[
                  priority[0],
                  b
                ];
      case /* Either */1 :
          return /* tuple */[
                  priority[0],
                  Curry._2(B.join, b, b$prime)
                ];
      case /* Neither */2 :
          return /* tuple */[
                  Curry._2(A.join, priority[0], priority[1]),
                  B.empty
                ];
      case /* Right */3 :
          return /* tuple */[
                  priority[0],
                  b$prime
                ];
      
    }
  };
  return {
          empty: empty,
          join: join
        };
}

export {
  ComparableOfOrderedType ,
  Make ,
  Pair ,
  LexicographicPair ,
  
}
/* No side effect */
